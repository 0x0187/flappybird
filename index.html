<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Bird Test</title>
    <style>
        canvas {
            border: 1px solid black;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let y_pos = 300;
        let x_pos = 0;

        let score = 0;

        let y_change = 0;
        let descend_rate = 350;
        let jump_power = 270;
        let gamespeed = 15;

        let terminal_vel = 600;

        let lost = false;

        let new_pipe_x = 0;

        let pipes = []; // {int: {pipe_x_pos, gap_width, gap_y_pos}}

        function genNewPipe() {
            console.log("generating pipe!");

            const thisPipe = [
                x_pos + 800,
                Math.floor(Math.random() * 101) + 150,
                Math.floor(Math.random() * (600 - 90)) + 90
            ];

            pipes.push(thisPipe);
        }

        function renderPipe(pipe) {
            const [pipe_x_pos, gap_width, gap_y_pos] = pipe;
            const screen_x_pos = pipe_x_pos - x_pos;

            const top_pipe_y_pos = 0;
            const bottom_pipe_y_pos = gap_y_pos + (gap_width / 2);

            const top_pipe_size = gap_y_pos - (gap_width / 2);
            const bottom_pipe_size = 600 - bottom_pipe_y_pos;

            ctx.fillStyle = 'green'; // Change color here
            ctx.fillRect(screen_x_pos, top_pipe_y_pos, 50, top_pipe_size); // top pipe
            ctx.fillRect(screen_x_pos, bottom_pipe_y_pos, 50, bottom_pipe_size); // bottom pipe
        }

        function renderPipes() {
            for (let i = 0; i < pipes.length; i++) {
                const pipe = pipes[i];

                // remove pipes past screen
                if ((pipe[0] - x_pos) + 50 < 0) {
                    pipes.splice(i, 1);
                    return;
                }

                renderPipe(pipe);
            }
        }

        function pipeCollisionCheck() {
            for (let i = 0; i < pipes.length; i++) {
                const [pipe_x_pos, gap_width, gap_y_pos] = pipes[i];
                const screen_x_pos = (pipe_x_pos - x_pos);

                // check x pos
                if (screen_x_pos < 400 + 30 && screen_x_pos + 50 > 400) {
                    // check y position
                    if (gap_y_pos - (gap_width / 2) > y_pos || gap_y_pos + (gap_width / 2) < y_pos + 30) {
                        lost = true;
                    }
                }
            }
        }

        function resetGame() {
            y_pos = 300;
            x_pos = 0;

            score = 0;

            y_change = 0;
            pipes = [];
            new_pipe_x = 0;
            gamespeed = 20;

            lost = false;
            console.log('reset!');
        }

        function update(dt) {
            if (!lost) {
                // score step
                score = (score + dt * gamespeed) + 0.5;

                // lost check
                if (y_pos + 30 > 600 || y_pos < 0) {
                    lost = true;
                }

                // pipe add check
                if (x_pos > new_pipe_x) {
                    // add a new pipe
                    genNewPipe();
                    new_pipe_x = x_pos + 400;
                }

                // step x position
                x_pos = x_pos + dt * (10 * gamespeed);

                // slightly increase gamespeed
                gamespeed = gamespeed * 1.0001;
            }

            // gravity
            y_change = y_change + (dt * descend_rate);
            if (y_change > terminal_vel) {
                y_change = terminal_vel;
            }

            // y_pos step
            y_pos = y_pos + y_change * dt;
        }

        function keyDownHandler(e) {
            console.log("pressed!");
            if (e.key === " ") {
                if (lost) {
                    resetGame();
                } else {
                    y_change = y_change - jump_power - Math.max(y_change, -100);
                }
            } else if (e.key === "k") {
                lost = true;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = 'white'; // Change color here
            ctx.fillRect(400, y_pos, 30, 30);

            if (lost) {
                ctx.fillStyle = 'black'; // Change color here
                ctx.font = '90px Arial';
                ctx.fillText('Gameover!', 150, 200);
                ctx.font = '40px Arial';
                ctx.fillText('Score: ' + Math.floor(score) + '.', 100, 370);
                ctx.fillText('Press space to reset.', 100, 450);
            } else {
                ctx.fillStyle = 'black'; // Change color here
                ctx.font = '20px Arial';
                ctx.fillText(Math.floor(score), 100, 50);
            }

            // call renderpipes
            renderPipes();
            pipeCollisionCheck();
        }

        let lastTime = 0;

        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            update(deltaTime / 1000);
            draw();

            requestAnimationFrame(gameLoop);
        }

        document.addEventListener("keydown", keyDownHandler, false);

        gameLoop();
    </script>
</body>
</html>
